# Password Authentication Implementation

## Overview

The application implements password-based authentication using bcrypt hashed passwords stored in the `API_USERS` Oracle database table. Authentication is performed via the `/oracle-auth` API endpoint with rate limiting protection.

## Authentication Flow

```
Client Application
    ↓
[User enters Email + Password]
    ↓
Hash Password (bcrypt, 12 rounds) → Password Hash
    ↓
POST /oracle-auth
    {
      "email": "user@example.com",
      "password_hash": "$2b$12$..."
    }
    ↓
Rate Limiter Check (15 requests/minute per email)
    ↓
Query API_USERS Table
    ↓
Response: { authenticated: true/false, is_admin: true/false }
```

## Database Table Structure

### API_USERS Table

```sql
CREATE TABLE API_USERS (
    USER_ID NUMBER(38,0) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USERNAME VARCHAR2(50) NOT NULL UNIQUE,
    PASSWORD_HASH VARCHAR2(255) NOT NULL,
    EMAIL VARCHAR2(100),
    FULL_NAME VARCHAR2(100),
    IS_ACTIVE NUMBER(1) DEFAULT 1 NOT NULL,
    IS_ADMIN NUMBER(1) DEFAULT 0 NOT NULL,
    CREATED_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    LAST_LOGIN TIMESTAMP,
    FAILED_LOGIN_ATTEMPTS NUMBER(3) DEFAULT 0,
    LOCKED_UNTIL TIMESTAMP
);
```

**Key Columns:**
- `EMAIL` - User email address (used for authentication)
- `PASSWORD_HASH` - Bcrypt hashed password (never plain text)
- `IS_ACTIVE` - Account status (1=active, 0=inactive)
- `IS_ADMIN` - Admin flag (1=admin, 0=user)

**Indexes:**
- `IDX_API_USERS_EMAIL` - Fast email lookups
- `IDX_API_USERS_USERNAME` - Fast username lookups

## API Endpoint

### POST `/oracle-auth`

**Description:** Check if email and password hash match in `API_USERS` table.

**Rate Limiting:** 15 requests per minute per email address

**Request Model:**
```python
class OracleAuthRequest(BaseModel):
    email: str = Field(..., description="User email address")
    password_hash: str = Field(..., description="Password hash to verify")
```

**Request Example:**
```json
{
  "email": "dearp@openbankingsolutions",
  "password_hash": "$2b$12$HyRo2NsnVPk9raBPcYpGRODKMIn75e0AHV48/y8XP0fgRt8e1ZbCy"
}
```

**Response Model:**
```python
class OracleAuthResponse(BaseModel):
    authenticated: bool = Field(..., description="True if email and password hash match, False otherwise")
    is_admin: bool = Field(False, description="True if user is admin, False otherwise (only set when authenticated=True)")
```

**Response Examples:**

**Successful Authentication (Admin):**
```json
{
  "authenticated": true,
  "is_admin": true
}
```

**Successful Authentication (Regular User):**
```json
{
  "authenticated": true,
  "is_admin": false
}
```

**Failed Authentication:**
```json
{
  "authenticated": false,
  "is_admin": false
}
```

**Rate Limit Exceeded (HTTP 429):**
```json
{
  "detail": "Rate limit exceeded. Maximum 15 requests per minute per email. Please try again later."
}
```

## Database Query

The authentication query checks for matching email and password hash:

```sql
SELECT IS_ADMIN
FROM API_USERS
WHERE UPPER(EMAIL) = UPPER(:email)
  AND PASSWORD_HASH = :password_hash
  AND IS_ACTIVE = 1
```

**Query Details:**
- **Case-insensitive email matching** - Uses `UPPER()` for both email and database value
- **Exact password hash match** - Compares provided hash with stored hash
- **Active users only** - Only checks users where `IS_ACTIVE = 1`
- **Returns IS_ADMIN** - Returns admin status when authentication succeeds

## Implementation Details

### 1. Service Method (`oracle_service.py`)

```python
def check_email_password_hash(self, email: str, password_hash: str) -> Dict[str, Any]:
    """
    Check if email and password hash match in API_USERS table.
    
    Returns:
        Dictionary with:
        - authenticated: bool - True if match found
        - is_admin: bool - True if user is admin (only when authenticated=True)
    """
    select_sql = """
    SELECT IS_ADMIN
    FROM API_USERS
    WHERE UPPER(EMAIL) = UPPER(:email)
      AND PASSWORD_HASH = :password_hash
      AND IS_ACTIVE = 1
    """
    
    cursor.execute(select_sql, {
        'email': email,
        'password_hash': password_hash
    })
    
    result = cursor.fetchone()
    
    if result:
        is_admin = bool(result[0]) if result[0] is not None else False
        return {
            'authenticated': True,
            'is_admin': is_admin
        }
    else:
        return {
            'authenticated': False,
            'is_admin': False
        }
```

### 2. API Endpoint (`main.py`)

```python
@app.post("/oracle-auth", response_model=OracleAuthResponse)
async def oracle_auth(
    request: OracleAuthRequest,
    oracle_service: OracleService = Depends(get_oracle_service)
):
    """
    Check if email and password hash match in API_USERS table.
    
    Returns authenticated (true/false) and is_admin flag.
    Rate limited to 15 requests per minute per email.
    """
    # Check rate limit
    is_allowed, remaining = oracle_auth_rate_limiter.is_allowed(request.email)
    
    if not is_allowed:
        raise HTTPException(
            status_code=429,
            detail="Rate limit exceeded. Maximum 15 requests per minute per email. Please try again later."
        )
    
    # Check email and password hash in database
    auth_result = oracle_service.check_email_password_hash(
        email=request.email,
        password_hash=request.password_hash
    )
    
    return OracleAuthResponse(
        authenticated=auth_result['authenticated'],
        is_admin=auth_result['is_admin']
    )
```

### 3. Rate Limiter (`rate_limiter.py`)

```python
class RateLimiter:
    """Simple in-memory rate limiter."""
    
    def __init__(self, max_requests: int = 15, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests: Dict[str, list] = defaultdict(list)
    
    def is_allowed(self, key: str) -> Tuple[bool, int]:
        """Check if a request is allowed for the given key."""
        current_time = time.time()
        
        # Clean up old requests outside the time window
        self.requests[key] = [
            timestamp 
            for timestamp in self.requests[key] 
            if current_time - timestamp < self.window_seconds
        ]
        
        # Check if limit exceeded
        if len(self.requests[key]) >= self.max_requests:
            return False, 0
        
        # Add current request timestamp
        self.requests[key].append(current_time)
        remaining = self.max_requests - len(self.requests[key])
        
        return True, remaining

# Global rate limiter instance
oracle_auth_rate_limiter = RateLimiter(max_requests=15, window_seconds=60)
```

## Password Hashing

### Requirements

- **Algorithm:** bcrypt
- **Rounds:** 12 (cost factor)
- **Format:** `$2b$12$...` (bcrypt format)
- **Library:** Use `bcryptjs` (JavaScript) or `bcrypt` (Python/Node.js server-side)

### Example Password Hash

**Password:** `@Buttermilk1985!!`

**Hash:** `$2b$12$HyRo2NsnVPk9raBPcYpGRODKMIn75e0AHV48/y8XP0fgRt8e1ZbCy`

### Client-Side Hashing (JavaScript/TypeScript)

```typescript
import bcrypt from 'bcryptjs';

async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(12);
  return await bcrypt.hash(password, salt);
}

// Usage
const passwordHash = await hashPassword('@Buttermilk1985!!');
// Result: $2b$12$HyRo2NsnVPk9raBPcYpGRODKMIn75e0AHV48/y8XP0fgRt8e1ZbCy
```

### Server-Side Hashing (Python)

```python
import bcrypt

def hash_password(password: str) -> str:
    salt = bcrypt.gensalt(rounds=12)
    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')

# Usage
password_hash = hash_password('@Buttermilk1985!!')
# Result: $2b$12$HyRo2NsnVPk9raBPcYpGRODKMIn75e0AHV48/y8XP0fgRt8e1ZbCy
```

## Usage Examples

### cURL Example

```bash
curl -X POST "http://localhost:8001/oracle-auth" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "dearp@openbankingsolutions",
    "password_hash": "$2b$12$HyRo2NsnVPk9raBPcYpGRODKMIn75e0AHV48/y8XP0fgRt8e1ZbCy"
  }'
```

**Response:**
```json
{
  "authenticated": true,
  "is_admin": true
}
```

### Python Example

```python
import requests

def authenticate(email: str, password_hash: str) -> dict:
    response = requests.post(
        "http://localhost:8001/oracle-auth",
        json={
            "email": email,
            "password_hash": password_hash
        }
    )
    return response.json()

# Usage
result = authenticate(
    "dearp@openbankingsolutions",
    "$2b$12$HyRo2NsnVPk9raBPcYpGRODKMIn75e0AHV48/y8XP0fgRt8e1ZbCy"
)

if result["authenticated"]:
    print(f"Authenticated! Admin: {result['is_admin']}")
else:
    print("Authentication failed")
```

### JavaScript/TypeScript Example

```typescript
async function authenticate(email: string, passwordHash: string): Promise<{authenticated: boolean, is_admin: boolean}> {
  const response = await fetch('http://localhost:8001/oracle-auth', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      email,
      password_hash: passwordHash
    })
  });
  
  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('Rate limit exceeded');
    }
    throw new Error('Authentication failed');
  }
  
  return await response.json();
}

// Usage
const result = await authenticate(
  'dearp@openbankingsolutions',
  '$2b$12$HyRo2NsnVPk9raBPcYpGRODKMIn75e0AHV48/y8XP0fgRt8e1ZbCy'
);

if (result.authenticated) {
  console.log(`Authenticated! Admin: ${result.is_admin}`);
} else {
  console.log('Authentication failed');
}
```

## Security Features

### 1. Password Hashing
- **Never stores plain text passwords** - Only bcrypt hashes are stored
- **Client-side hashing** - Password is hashed before sending to API
- **HTTPS required** - Always use HTTPS in production

### 2. Rate Limiting
- **15 requests per minute per email** - Prevents brute force attacks
- **HTTP 429 response** - Clear error message when limit exceeded
- **In-memory tracking** - Fast and efficient rate limiting

### 3. Account Status Checks
- **Active users only** - Only `IS_ACTIVE = 1` users can authenticate
- **Case-insensitive email** - Prevents case-based enumeration

### 4. Error Handling
- **Generic error messages** - Doesn't reveal if email exists
- **Logging** - All authentication attempts are logged
- **Exception handling** - Proper error handling and HTTP status codes

## Sample User Data

### Example User Record

```sql
INSERT INTO API_USERS (
    USERNAME,
    PASSWORD_HASH,
    EMAIL,
    FULL_NAME,
    IS_ACTIVE,
    IS_ADMIN,
    CREATED_DATE
) VALUES (
    'douglasearp',
    '$2b$12$HyRo2NsnVPk9raBPcYpGRODKMIn75e0AHV48/y8XP0fgRt8e1ZbCy',  -- @Buttermilk1985!!
    'dearp@openbankingsolutions',
    'Doug Earp',
    1,  -- IS_ACTIVE
    1,  -- IS_ADMIN
    CURRENT_TIMESTAMP
);
```

## Response Status Codes

| Status Code | Description |
|------------|-------------|
| `200 OK` | Authentication check completed successfully |
| `429 Too Many Requests` | Rate limit exceeded (15 requests/minute) |
| `500 Internal Server Error` | Server error during authentication check |

## Notes

1. **No JWT Tokens** - This endpoint only validates credentials, it does not issue tokens
2. **Password Hash Required** - Client must hash password before sending (never send plain password)
3. **Schema Prefix** - Database queries may need schema prefix (e.g., `OBS_SCHEMA.API_USERS`)
4. **Rate Limiter Reset** - Rate limit resets after 60 seconds (1 minute window)
5. **Admin Flag** - `is_admin` is only meaningful when `authenticated = true`
6. **Inactive Users** - Users with `IS_ACTIVE = 0` cannot authenticate
7. **Case Sensitivity** - Email matching is case-insensitive, password hash is case-sensitive

## Related Files

- **API Endpoint:** `src/obs_sftp_file_processor/main.py` (line 1823)
- **Service Method:** `src/obs_sftp_file_processor/oracle_service.py` (line 807)
- **Models:** `src/obs_sftp_file_processor/models.py` (lines 137-148)
- **Rate Limiter:** `src/obs_sftp_file_processor/rate_limiter.py`
- **Table Schema:** `database/create_api_users_tables.sql`
- **Sample Data:** `database/insert_api_users_task_000006.sql`


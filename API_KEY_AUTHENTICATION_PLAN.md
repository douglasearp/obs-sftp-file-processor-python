# API Key Authentication Plan (Oracle-Based)

This document outlines an alternative authentication approach using API Keys stored in Oracle database, compared to JWT authentication.

---

## üéØ API Key vs JWT Comparison

### **API Key Authentication (Oracle-Based)**

**Pros:**
- ‚úÖ **Simpler Implementation** - No token generation/validation logic needed
- ‚úÖ **Centralized Management** - All keys stored in Oracle, easy to revoke
- ‚úÖ **No Expiration Logic** - Keys don't expire unless explicitly revoked
- ‚úÖ **Database-Driven** - Can track usage, associate with users, set permissions
- ‚úÖ **Easy Revocation** - Simply update database to disable key
- ‚úÖ **Audit Trail** - Track which API key accessed which resources
- ‚úÖ **No Cryptographic Complexity** - No JWT signing/verification needed
- ‚úÖ **Stateless Validation** - Fast database lookup (indexed query)
- ‚úÖ **User Association** - Direct link to `USER_LOGIN` table in Oracle

**Cons:**
- ‚ùå **Database Dependency** - Every request requires database lookup
- ‚ùå **Network Overhead** - Additional database query per request
- ‚ùå **Key Management** - Need secure key generation/storage
- ‚ùå **No Built-in Expiration** - Must implement expiration logic manually
- ‚ùå **Key Exposure Risk** - If key is leaked, must revoke and regenerate

### **JWT Authentication**

**Pros:**
- ‚úÖ **Stateless** - No database lookup needed (token is self-contained)
- ‚úÖ **Fast Validation** - Cryptographic verification only
- ‚úÖ **Built-in Expiration** - Tokens expire automatically
- ‚úÖ **Scalable** - No database queries per request

**Cons:**
- ‚ùå **More Complex** - Token generation, signing, validation logic
- ‚ùå **Harder to Revoke** - Requires token blacklist (database needed anyway)
- ‚ùå **Expiration Management** - Must handle refresh tokens
- ‚ùå **Cryptographic Complexity** - Secret key management, algorithm selection

---

## üìä Recommendation

**API Key Authentication is EASIER** for your use case because:
1. You already have Oracle database infrastructure
2. You want to link authentication to `USER_LOGIN` table
3. Simpler implementation (no JWT libraries needed)
4. Better audit trail (track API key usage)
5. Easier key management (revoke/regenerate in database)

**Performance Note:** Database lookup is fast with proper indexing (typically <10ms), which is acceptable for most API use cases.

---

## üèóÔ∏è Architecture Overview

### **Authentication Flow**

```
1. Client sends request with API Key in header:
   Authorization: ApiKey <api-key-value>

2. FastAPI extracts API key from header

3. FastAPI queries Oracle API_KEYS table:
   SELECT * FROM API_KEYS WHERE KEY_VALUE = :api_key AND IS_ACTIVE = 1

4. If found, retrieve associated USER_LOGIN record:
   SELECT * FROM USER_LOGIN WHERE USER_ID = :user_id

5. Validate user is active and not locked

6. Attach user context to request (via FastAPI dependency)

7. Endpoint executes with authenticated user context
```

---

## üìã Implementation Plan

### **Phase 1: Database Schema Design**

#### **Option A: Extend Existing USER_LOGIN Table**
Add API key columns directly to `USER_LOGIN` table:

```sql
ALTER TABLE USER_LOGIN ADD (
    API_KEY VARCHAR2(64) UNIQUE,
    API_KEY_HASH VARCHAR2(255),  -- Hashed version for security
    API_KEY_CREATED_DATE TIMESTAMP,
    API_KEY_LAST_USED TIMESTAMP,
    API_KEY_EXPIRES_DATE TIMESTAMP,
    API_KEY_IS_ACTIVE NUMBER(1) DEFAULT 1
);

CREATE INDEX IDX_USER_LOGIN_API_KEY ON USER_LOGIN(API_KEY);
```

**Pros:**
- Simple schema (one table)
- Direct relationship (no joins needed)
- Easy to query

**Cons:**
- One API key per user
- Mixed concerns (user data + API key)

#### **Option B: Separate API_KEYS Table (Recommended)**
Create dedicated table for API keys:

```sql
CREATE TABLE API_KEYS (
    API_KEY_ID NUMBER(38,0) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USER_ID NUMBER(38,0) NOT NULL,
    KEY_NAME VARCHAR2(100),  -- Friendly name: "Production API Key", "Dev Key", etc.
    KEY_VALUE VARCHAR2(64) NOT NULL UNIQUE,  -- The actual API key
    KEY_HASH VARCHAR2(255) NOT NULL,  -- Hashed version for validation
    IS_ACTIVE NUMBER(1) DEFAULT 1 NOT NULL,
    CREATED_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CREATED_BY_USER VARCHAR2(50),
    LAST_USED_DATE TIMESTAMP,
    LAST_USED_IP VARCHAR2(45),  -- Track IP address
    EXPIRES_DATE TIMESTAMP,
    REVOKED_DATE TIMESTAMP,
    REVOKED_BY_USER VARCHAR2(50),
    REVOKE_REASON VARCHAR2(255),
    USAGE_COUNT NUMBER(10) DEFAULT 0,  -- Track how many times used
    FOREIGN KEY (USER_ID) REFERENCES USER_LOGIN(USER_ID)
);

CREATE UNIQUE INDEX IDX_API_KEYS_KEY_VALUE ON API_KEYS(KEY_VALUE);
CREATE INDEX IDX_API_KEYS_USER_ID ON API_KEYS(USER_ID);
CREATE INDEX IDX_API_KEYS_ACTIVE ON API_KEYS(IS_ACTIVE, EXPIRES_DATE);
```

**Pros:**
- Multiple API keys per user (dev, production, etc.)
- Better separation of concerns
- Enhanced audit trail
- Easier key management

**Cons:**
- Requires JOIN to get user information
- More complex queries

---

### **Phase 2: API Key Generation Strategy**

#### **Key Format Options:**

**Option A: UUID-based (Recommended)**
```
Format: apk_<32-char-hex>
Example: apk_a1b2c3d4e5f6789012345678901234ab
```
- Cryptographically random
- 36 characters total (with prefix)
- Easy to generate

**Option B: Base64-encoded Random**
```
Format: <44-char-base64>
Example: dGhpc2lzYW5leGFtcGxlYXBpa2V5Zm9ydGVzdGluZw==
```
- Shorter (44 characters)
- URL-safe

**Option C: Custom Format**
```
Format: <prefix>-<user-id>-<random>
Example: UB-12345-abc123def456
```
- Human-readable
- Includes user ID (security consideration)

**Recommendation:** Use **Option A (UUID-based)** with prefix for clarity.

#### **Key Generation Process:**
```python
# Pseudo-code (NOT actual implementation)
import secrets

def generate_api_key():
    # Generate 32 random bytes
    random_bytes = secrets.token_bytes(32)
    # Convert to hex string
    hex_string = random_bytes.hex()
    # Add prefix
    api_key = f"apk_{hex_string}"
    # Hash for storage (using bcrypt or SHA-256)
    api_key_hash = hash_api_key(api_key)
    return api_key, api_key_hash
```

---

### **Phase 3: Components to Create**

#### **1. API Key Configuration (`src/obs_sftp_file_processor/api_key_config.py`)**
```python
# Configuration for API key authentication
class ApiKeyConfig:
    header_name: str = "Authorization"  # or "X-API-Key"
    key_prefix: str = "ApiKey"  # or "Bearer"
    key_length: int = 32  # bytes
    key_prefix_string: str = "apk_"
    validate_expiration: bool = True
    track_usage: bool = True  # Update last_used_date, usage_count
```

#### **2. API Key Models (`src/obs_sftp_file_processor/api_key_models.py`)**
```python
# Pydantic models for API key operations
- ApiKeyCreate - Create new API key
- ApiKeyResponse - Return API key info (without actual key)
- ApiKeyListResponse - List user's API keys
- ApiKeyRevokeRequest - Revoke API key
```

#### **3. API Key Service (`src/obs_sftp_file_processor/api_key_service.py`)**
```python
# Functions to implement:
- generate_api_key() - Create new API key
- hash_api_key(key) - Hash API key for storage
- verify_api_key(key, key_hash) - Verify key against hash
- get_api_key_by_value(key_value) - Query Oracle by key
- get_user_by_api_key(key_value) - Get user associated with key
- validate_api_key(key_value) - Full validation (active, not expired, etc.)
- update_api_key_usage(key_id, ip_address) - Track usage
- revoke_api_key(key_id, reason) - Disable API key
- create_api_key_for_user(user_id, key_name) - Create key for user
- list_api_keys_for_user(user_id) - Get all keys for user
```

#### **4. API Key Dependencies (`src/obs_sftp_file_processor/api_key_dependencies.py`)**
```python
# FastAPI dependencies
- get_api_key_from_header() - Extract API key from Authorization header
- get_current_user_from_api_key() - Validate key and return user
- get_current_active_user() - Ensure user is active
```

#### **5. API Key Routes (`src/obs_sftp_file_processor/api_key_routes.py`)**
```python
# Endpoints for API key management
- POST /api-keys - Create new API key (for current user or admin)
- GET /api-keys - List user's API keys
- GET /api-keys/{key_id} - Get specific API key info
- POST /api-keys/{key_id}/revoke - Revoke API key
- DELETE /api-keys/{key_id} - Delete API key
```

---

### **Phase 4: Request Flow**

#### **Client Request:**
```http
GET /oracle/ach-files HTTP/1.1
Host: localhost:8001
Authorization: ApiKey apk_a1b2c3d4e5f6789012345678901234ab
```

#### **FastAPI Processing:**
1. **Extract API Key:**
   ```python
   # From Authorization header
   # Format: "ApiKey apk_<value>" or "Bearer apk_<value>"
   ```

2. **Query Oracle:**
   ```sql
   SELECT 
       ak.API_KEY_ID,
       ak.USER_ID,
       ak.KEY_VALUE,
       ak.KEY_HASH,
       ak.IS_ACTIVE,
       ak.EXPIRES_DATE,
       ul.USERNAME,
       ul.EMAIL,
       ul.IS_ACTIVE as USER_IS_ACTIVE
   FROM API_KEYS ak
   JOIN USER_LOGIN ul ON ak.USER_ID = ul.USER_ID
   WHERE ak.KEY_VALUE = :api_key
     AND ak.IS_ACTIVE = 1
     AND ul.IS_ACTIVE = 1
   ```

3. **Validate:**
   - Key exists
   - Key is active
   - User is active
   - Key not expired (if expiration set)
   - Verify key hash matches (security)

4. **Update Usage (Optional):**
   ```sql
   UPDATE API_KEYS 
   SET LAST_USED_DATE = CURRENT_TIMESTAMP,
       LAST_USED_IP = :ip_address,
       USAGE_COUNT = USAGE_COUNT + 1
   WHERE API_KEY_ID = :key_id
   ```

5. **Attach User Context:**
   ```python
   # FastAPI dependency returns user object
   current_user = User(
       user_id=...,
       username=...,
       email=...
   )
   ```

---

### **Phase 5: Security Considerations**

#### **1. Key Storage**
- **Never store plain text keys** in database
- Store hashed version (bcrypt or SHA-256)
- Only return plain key once (during creation)
- Hash verification on every request

#### **2. Key Transmission**
- Use HTTPS/TLS (required)
- API key in Authorization header (not URL)
- Consider rate limiting per API key

#### **3. Key Rotation**
- Allow users to regenerate keys
- Implement key expiration dates
- Notify users before expiration
- Automatic revocation of expired keys

#### **4. Key Revocation**
- Immediate revocation (update IS_ACTIVE = 0)
- Track revocation reason
- Log all revoked key access attempts
- Alert on revoked key usage

#### **5. Audit Trail**
- Log every API key usage
- Track IP addresses
- Monitor for suspicious patterns
- Rate limit per key (prevent abuse)

---

### **Phase 6: Database Query Optimization**

#### **Indexing Strategy:**
```sql
-- Primary lookup index
CREATE UNIQUE INDEX IDX_API_KEYS_KEY_VALUE ON API_KEYS(KEY_VALUE);

-- User lookup index
CREATE INDEX IDX_API_KEYS_USER_ID ON API_KEYS(USER_ID);

-- Active key lookup (for validation)
CREATE INDEX IDX_API_KEYS_ACTIVE ON API_KEYS(IS_ACTIVE, EXPIRES_DATE) 
WHERE IS_ACTIVE = 1;

-- Composite index for common queries
CREATE INDEX IDX_API_KEYS_LOOKUP ON API_KEYS(KEY_VALUE, IS_ACTIVE, USER_ID);
```

#### **Query Performance:**
- **Expected:** <10ms with proper indexing
- **Cache Option:** Redis cache for frequently used keys (optional)
- **Connection Pooling:** Use existing Oracle connection pool

---

### **Phase 7: Implementation Steps**

1. ‚úÖ **Database Schema**
   - Create `API_KEYS` table
   - Add indexes
   - Create initial API key for admin user

2. ‚úÖ **Core Components**
   - Create `api_key_service.py` with Oracle queries
   - Create `api_key_dependencies.py` for FastAPI
   - Create `api_key_models.py` for Pydantic models

3. ‚úÖ **Key Management**
   - Create `api_key_routes.py` for key management endpoints
   - Implement key generation/hashing/verification

4. ‚úÖ **Protect Endpoints**
   - Add `Depends(get_current_user_from_api_key)` to protected endpoints
   - Keep health checks public

5. ‚úÖ **Testing**
   - Test key generation
   - Test key validation
   - Test protected endpoints
   - Test key revocation

6. ‚úÖ **Documentation**
   - Update API docs with authentication
   - Create key management guide
   - Update README

---

## üìä Comparison: API Key vs JWT

| Feature | API Key (Oracle) | JWT |
|---------|------------------|-----|
| **Implementation Complexity** | ‚≠ê‚≠ê Simple | ‚≠ê‚≠ê‚≠ê‚≠ê Complex |
| **Database Dependency** | ‚úÖ Yes (one query) | ‚ùå No (stateless) |
| **Key Management** | ‚úÖ Easy (database) | ‚ö†Ô∏è Harder (blacklist needed) |
| **Revocation** | ‚úÖ Instant (DB update) | ‚ö†Ô∏è Requires blacklist |
| **User Association** | ‚úÖ Direct (FK to USER_LOGIN) | ‚ö†Ô∏è Token payload only |
| **Audit Trail** | ‚úÖ Built-in (track usage) | ‚ö†Ô∏è Must implement separately |
| **Expiration** | ‚úÖ Database field | ‚úÖ Built-in |
| **Performance** | ‚ö†Ô∏è ~10ms (DB query) | ‚úÖ <1ms (crypto only) |
| **Scalability** | ‚úÖ Good (with caching) | ‚úÖ Excellent |
| **Key Rotation** | ‚úÖ Easy | ‚ö†Ô∏è More complex |

---

## üéØ Recommendation for Your Use Case

**Use API Key Authentication** because:
1. ‚úÖ You already have Oracle database
2. ‚úÖ You want to link to `USER_LOGIN` table
3. ‚úÖ Simpler implementation (no JWT libraries)
4. ‚úÖ Better audit trail (track key usage)
5. ‚úÖ Easier key management (revoke/regenerate)
6. ‚úÖ Performance is acceptable (indexed query <10ms)

**Performance Note:** Database lookup is fast with proper indexing. If you need sub-millisecond response times, consider caching frequently used keys in Redis (optional).

---

## üìù Key Management Workflow

### **Creating API Key:**
1. User/admin requests new API key
2. System generates random key (UUID-based)
3. Hash key for storage
4. Insert into `API_KEYS` table
5. Return plain key once (user must save it)
6. Never return plain key again

### **Using API Key:**
1. Client includes key in Authorization header
2. FastAPI extracts key
3. Query Oracle `API_KEYS` table
4. Validate key (active, not expired, user active)
5. Update usage statistics
6. Attach user context to request

### **Revoking API Key:**
1. User/admin requests revocation
2. Update `API_KEYS.IS_ACTIVE = 0`
3. Set `REVOKED_DATE = CURRENT_TIMESTAMP`
4. Log revocation reason
5. Future requests with this key return 401

---

## üîí Security Best Practices

1. **Key Generation:**
   - Use cryptographically secure random (secrets module)
   - Minimum 32 bytes (256 bits)
   - Add prefix for identification

2. **Key Storage:**
   - Hash keys before storing (bcrypt or SHA-256)
   - Never log plain keys
   - Only return key once during creation

3. **Key Transmission:**
   - Require HTTPS/TLS
   - Use Authorization header (not URL params)
   - Consider rate limiting

4. **Key Validation:**
   - Verify hash on every request
   - Check expiration date
   - Validate user is active
   - Track usage for audit

5. **Key Rotation:**
   - Allow users to regenerate keys
   - Set expiration dates
   - Notify before expiration
   - Revoke old keys when new ones are created

---

## üìö API Usage Examples

### **Create API Key:**
```bash
POST /api-keys
Authorization: Bearer <existing-api-key>  # Or use login endpoint first
Content-Type: application/json

{
  "key_name": "Production API Key",
  "expires_days": 90
}

Response:
{
  "api_key_id": 1,
  "key_name": "Production API Key",
  "key_value": "apk_a1b2c3d4e5f6789012345678901234ab",  # Only shown once!
  "created_date": "2025-11-05T10:00:00",
  "expires_date": "2026-02-03T10:00:00"
}
```

### **Use API Key:**
```bash
GET /oracle/ach-files
Authorization: ApiKey apk_a1b2c3d4e5f6789012345678901234ab
```

### **List API Keys:**
```bash
GET /api-keys
Authorization: ApiKey apk_a1b2c3d4e5f6789012345678901234ab

Response:
{
  "keys": [
    {
      "api_key_id": 1,
      "key_name": "Production API Key",
      "created_date": "2025-11-05T10:00:00",
      "last_used_date": "2025-11-05T15:30:00",
      "expires_date": "2026-02-03T10:00:00",
      "usage_count": 1250,
      "is_active": true
    }
    # Note: key_value is NOT returned
  ]
}
```

### **Revoke API Key:**
```bash
POST /api-keys/1/revoke
Authorization: ApiKey apk_a1b2c3d4e5f6789012345678901234ab
Content-Type: application/json

{
  "reason": "Key compromised"
}
```

---

## ‚úÖ Implementation Checklist

- [ ] Create `API_KEYS` table in Oracle
- [ ] Create indexes for performance
- [ ] Create `api_key_service.py` with Oracle queries
- [ ] Create `api_key_dependencies.py` for FastAPI
- [ ] Create `api_key_models.py` for Pydantic models
- [ ] Create `api_key_routes.py` for key management
- [ ] Implement key generation/hashing
- [ ] Add `Depends(get_current_user_from_api_key)` to protected endpoints
- [ ] Test key creation
- [ ] Test key validation
- [ ] Test protected endpoints
- [ ] Test key revocation
- [ ] Update API documentation
- [ ] Update README with authentication guide

---

## üéì Summary

**API Key Authentication with Oracle lookup is:**
- ‚úÖ **Easier** than JWT (no cryptographic complexity)
- ‚úÖ **Simpler** implementation (database query vs token validation)
- ‚úÖ **Better** for audit trails (track usage in database)
- ‚úÖ **Easier** key management (revoke instantly in database)
- ‚úÖ **Direct** link to `USER_LOGIN` table
- ‚ö†Ô∏è **Slightly slower** than JWT (~10ms vs <1ms, but acceptable)

**Recommendation:** Use API Key authentication for your use case. It's simpler, easier to manage, and fits well with your existing Oracle infrastructure.

